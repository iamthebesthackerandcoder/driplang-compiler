---
layout: default
title: Language Reference
nav_order: 3
---

# Language Reference

DripLang mirrors Julia's syntax and semantics while swapping every reserved keyword for Gen Z slang. The compiler remaps tokens back to Julia before invoking `Meta.parseall`, so any valid DripLang program becomes valid Julia at the lowered AST level.

## Keywords

| Purpose | DripLang | Julia |
|---------|----------|-------|
| Function | `flex` | `function` |
| Anonymous arrow | `glow` | `->` |
| Block terminator | `yeet` | `end` |
| If / Else if / Else | `fr` / `lowkey` / `no_cap` | `if` / `elseif` / `else` |
| Loops | `keepit100` / `loopin` | `while` / `for` |
| Membership | `vibein` | `in` |
| Structs | `main_character` / `side_character` | `mutable struct` / `struct` |
| Begin block | `squad` | `begin` |
| Scoped binding | `bet` | `let` |
| Flow control | `bounce` / `ghost` / `spin` | `return` / `break` / `continue` |
| Literals | `facts` / `cap` / `void` | `true` / `false` / `nothing` |
| Modules & imports | `clout` / `shoutout` / `scoop` / `plug` | `module` / `export` / `import` / `using` |
| Macros | `vibecheck` | `macro` |

Identifiers, literals, string interpolation, and operators all follow Julia rules. Broadcasting, comprehensions, macro calls, and multiple dispatch signatures transfer unchanged.

## Functions and Dispatch

```
flex roast(name::AbstractString)
    spill("ur code mid,", name)
yeet

flex roast(name)
    spill("who even are you?", name)
yeet
```

Multiple definitions of `flex` create separate Julia methods. Use `glow` to author lambdas: `nums glow sum(nums)`.

## Control Flow

```
fr score > 9000
    spill("unstoppable")
lowkey score > 1000
    spill("big mood")
no_cap
    spill("keep grinding")
yeet
```

Loop constructs (`keepit100`, `loopin`) map to Julia `while` and `for`. Use `ghost` and `spin` to exit or continue.

## Structs

```
main_character Avatar
    name::String
    level::Int
yeet
```

Struct bodies accept the same field declarations, inner constructors, and method blocks that Julia supports.

## Modules & Imports

```
clout MyPack
    shoutout flex
    plug DripStd

    flex flex()
        spill("module vibes")
        bounce void
    yeet
yeet
```

Modules generated by the compiler are namespaced under auto-generated identifiers unless you override them with `--module-name` in the CLI or `module_name` when calling `compile_string`.

## Runtime Semantics

- Static scoping and closures behave exactly like Julia.
- Type annotations are optional; when present they feed Julia's dispatch machinery.
- Macros invoked through `@` operate on the remapped Julia AST, so any Julia macro can be imported and used from DripLang with `plug`.
- Errors bubble up as Julia exceptions. The compiler wraps lexing, parsing, and semantic issues in structured diagnostics before evaluation.

## Compilation Pipeline

1. **Lexing** - `Tokenize.jl` produces tokens and rewrites slang keywords into Julia tokens while retaining original source ranges for diagnostics.
2. **Parsing** - `Meta.parseall` turns the normalized source into Julia AST nodes. Incomplete parses emit detailed diagnostics mapped back to the original slang lexemes.
3. **Semantic pass** - The analyzer collects exports, typed method signatures, and the implicit entrypoint (`flex main()` by default).
4. **Lowering** - The AST is emitted verbatim into a newly created Julia `Module`. Methods can be precompiled for faster first-call latency.
5. **Runtime** - The runtime wrapper evaluates lowered expressions, manages modules, and offers CLI/REPL entrypoints.

## File Types

- `.drip` - DripLang source files
- `.dripc` - reserved for future compiled caches

Consult the [standard library](stdlib.md) and [tooling guide](tooling.md) to round out your workflow.
